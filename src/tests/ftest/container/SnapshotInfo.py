#!/usr/bin/python
"""
  (C) Copyright 2019 Intel Corporation.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  GOVERNMENT LICENSE RIGHTS-OPEN SOURCE SOFTWARE
  The Government's rights to use, modify, reproduce, release, perform, display,
  or disclose this software are subject to the terms of the Apache License as
  provided in Contract No. B609815.
  Any reproduction of computer software, computer software documentation, or
  portions thereof marked with this legend must also reproduce the markings.
"""
from __future__ import print_function
import os
import traceback
import sys
import random
import string
import json
from avocado import Test

# pylint: disable=wrong-import-position
sys.path.append('./util')
sys.path.append('../util')
sys.path.append('../../../utils/py')
sys.path.append('./../../utils/py')

# pylint: disable=import-error
import ServerUtils
import WriteHostFile
from daos_api import (DaosContext, DaosPool, DaosContainer, DaosSnapshot,
                      DaosLog, DaosApiError)

# pylint: disable=broad-except
class Snapshot(Test):
    """
    Epic: DAOS-2249 Create system level tests that cover basic snapshot
          functionality.
    Testcase:
          DAOS-1370 Basic snapshot test
          DAOS-1386 Test container SnapShot information
          DAOS-1371 Test list snapshots
          DAOS-1395 Test snapshot destroy
          DAOS-1402 Test creating multiple snapshots

    Test Class Description:
          Start DAOS servers, set up the pool and container for the snapshot
          testcases.
    """

    def __init__(self, *args, **kwargs):
        super(Snapshot, self).__init__(*args, **kwargs)
        self.snapshot = None

    def setUp(self):

        self.log.info("==In setUp...")
        # get paths from the build_vars generated by build
        with open('../../../.build_vars.json') as finput:
            build_paths = json.load(finput)
        basepath = os.path.normpath(build_paths['PREFIX']  + "/../")

        server_group = self.params.get("server_group", '/server/',
                                       'daos_server')

        # setup the DAOS python API
        self.context = DaosContext(build_paths['PREFIX'] + '/lib/')
        self.d_log = DaosLog(self.context)

        self.hostlist = self.params.get("test_machines", '/run/hosts/*')
        hostfile = WriteHostFile.WriteHostFile(self.hostlist, self.workdir)

        ServerUtils.runServer(hostfile, server_group, basepath)

        # Set up the pool and container.
        try:
            # parameters used in pool create
            createmode = self.params.get("mode", '/run/pool/createmode/')
            createsetid = self.params.get("setname", '/run/pool/createset/')
            createsize = self.params.get("size", '/run/pool/createsize/*')
            createuid = os.geteuid()
            creategid = os.getegid()

            # initialize a pool object then create the underlying
            # daos storage
            self.log.info("==Creating a pool")
            self.pool = DaosPool(self.context)
            self.pool.create(createmode, createuid, creategid,
                             createsize, createsetid, None)

            # need a connection to create container
            self.pool.connect(1 << 1)

            # create a container
            self.log.info("==Creating a container")
            self.container = DaosContainer(self.context)
            self.container.create(self.pool.handle)

            # now open it
            self.log.info("==Open the container")
            self.container.open()

        except DaosApiError as error:
            self.log.info(error)
            self.log.info(traceback.format_exc())
            self.fail("##Test failed before snapshot taken")

    def tearDown(self):
        try:
            if self.container:
                self.log.info("==tearDown, close and destroy the container.")
                self.container.close()
                self.container.destroy()
            if self.pool:
                self.log.info("==tearDown, disconnect and destroy the pool.")
                self.pool.disconnect()
                self.pool.destroy(1)
        finally:
            self.log.info("==tearDown, stop the DAOS server.")
            ServerUtils.stopServer()

    def display_DaosContainer(self):
        self.log.info("==display_DaosContainer========================")
        self.log.info("self.container OBJ=                {0}"\
            .format(self.container))
        self.log.info("self.container.context obj=        {0}"\
            .format(self.container.context))
        self.log.info("self.container.context.libdaos=    {0}"\
            .format(self.container.context.libdaos))
        self.log.info("self.container.context.libtest=    {0}"\
            .format(self.container.context.libtest))
        self.log.info("self.container.context.ftable=     {0}"\
            .format(self.container.context.ftable))
        self.log.info("self.container.uuid obj=           {0}"\
            .format(self.container.uuid))
        self.log.info("self.container.coh=                {0}"\
            .format(self.container.coh))
        self.log.info("self.container.poh=                {0}"\
            .format(self.container.poh))
        self.log.info("self.container.info obj=           {0}"\
            .format(self.container.info))
        self.log.info("self.container.info.ci_uuid=       {0}"\
            .format(self.container.info.ci_uuid))
        self.log.info("self.container.info.es_hce=        {0}"\
            .format(self.container.info.es_hce))
        self.log.info("self.container.info.es_lre=        {0}"\
            .format(self.container.info.es_lre))
        self.log.info("self.container.info.es_lhe=        {0}"\
            .format(self.container.info.es_lhe))
        self.log.info("self.container.info.es_ghce=       {0}"\
            .format(self.container.info.es_ghce))
        self.log.info("self.container.info.es_glre=       {0}"\
            .format(self.container.info.es_glre))
        self.log.info("self.container.info.es_ghpce=      {0}"\
            .format(self.container.info.es_ghpce))
        self.log.info("self.container.info.ci_nsnapshots= {0}"\
            .format(self.container.info.ci_nsnapshots))
        self.log.info("self.container.info.ci_snapshots=  {0}"\
            .format(self.container.info.ci_snapshots))
        self.log.info("self.container.info.ci_min_slipped_epoch= {0}"\
            .format(self.container.info.ci_min_slipped_epoch))
        self.log.info("==========================")

    def display_Snapshot(self,snapshot):
        self.log.info("==display_Snapshot=============================")
        self.log.info("snapshot=                 {0}".format(snapshot))
        self.log.info("snapshot.context=         {0}".format(snapshot.context))
        self.log.info("snapshot.context.libdaos= {0}"\
            .format(snapshot.context.libdaos))
        self.log.info("snapshot.context.libtest= {0}"\
            .format(snapshot.context.libtest))
        self.log.info("snapshot.context.ftable= {0}"\
            .format(snapshot.context.ftable))
        self.log.info("snapshot.context.ftable[list-attr]= {0}"\
            .format(snapshot.context.ftable["list-attr"]))
        self.log.info("snapshot.context.ftable[test-event]={0}"\
            .format(snapshot.context.ftable["test-event"]))
        self.log.info("snapshot.name=  {0}".format(snapshot.name))
        self.log.info("snapshot.epoch= {0}".format(snapshot.epoch))
        self.log.info("==================================")

    def take_Snapshot(self, epoch):
        self.log.info("==Taking snapshot for:")
        self.log.info("    self.container.coh= {0}".format(self.container.coh))
        self.log.info("    epoch=              {0}".format(epoch))
        substep = step + ".1"
        snapshot = DaosSnapshot(self.context) #DaosContext(build_paths[..]/lib/)
        #self.display_Snapshot(snapshot)    #display ss info before ss created
        #    Verify initial epic should be 0
        substep = step + ".2"
        snapshot.create(self.container.coh, epoch)
        self.display_Snapshot(snapshot)    #display ss info after ss created
        return snapshot

    def verify_Snapshot(self, snapshot1, snapshot2):
        self.log.info("==Verifying snapshot for: \n     {1}  and \n     {2}"\
            .format(snapshot1,snapshot2))
        status = 1
        ss_context = ["libdaos","libtest","ftable","ftable[list-attr]",\
                      "ftable[test-event]"]
        for ct in ss_context:
            if snapshot1.contexti.ct != snapshot2.context.ct:
                status = 0
        if snapshot1.name != snapshot2.name:
            status = 0
        if snapshot1.epoch == snapshot2.epoch:
            status = 0
        return status

    def append_snapshot_testdata(self, coh, epoch, snapshot, test_data):
        self.coh_list.append(coh)
        self.container_epoch_list.append(epoch)
        self.snapshot_list.append(snapshot)
        self.test_data.append(test_data)
        self.log.info("=====>append_snapshot_testdata {0},{1},{2},{3}"\
            .format(coh, epoch, snapshot, test_data))
        return


    def test_snapshot_create_negativetest(self):
        """
        Test ID: DAOS-1390 Verify snap_create bad parameter behavior

        Test Description:
                (1)Create an object, write random adata into it, and take
                   a snapshot.
                (2)Verify the snapshot is working properly.
                (3)Test snapshot with an invalid container handler
                (4)Test snapshot with a NULL container handler
                (5)Test snapshot with an invalid epoch

        Use Cases:
        :avocado: tags=snap,snapshotNegative,snapshotCreateNegative
        """
        snapshot_index = 1
        #(1)Create an object, write some data into it, and take a snapshot
        try:
            obj_cls = self.params.get("obj_class", '/run/object_class/*')
            dkey = "dkey"
            akey = "akey"
            size = random.randint(1, 100) + 1
            rand_str = lambda n: ''.join([random.choice(string.lowercase)\
                    for i in xrange(n)])
            thedata = "--->>>Happy Daos Snapshot-Create Negative Testing " + \
                    str(snapshot_index) + "<<<---" + rand_str(size)
            datasize = len(thedata) + 1
            obj, epoch = self.container.write_an_obj(thedata,
                                                     datasize,
                                                     dkey,
                                                     akey,
                                                     obj_cls=obj_cls)
            obj.close()
            ##Take a snapshot of the container
            self.snapshot = DaosSnapshot(self.context)
            self.snapshot.create(self.container.coh, epoch)
            self.log.info("==Wrote an object and created a snapshot")

            #Display snapshot
            substep = "1." + str(snapshot_index)
            self.log.info("==(1)Test step {0}".format(substep))
            self.log.info("==container epoch=     {0}".format(epoch))
            self.log.info("==self.snapshot.epoch= {0}"\
                .format(self.snapshot.epoch))
            self.display_Snapshot(self.snapshot)

        except DaosApiError as error:
            self.fail("##Test failed during the initial object write.\n{0}"
                  .format(error))

        #(2)Verify the snapshot is working properly.
        try:
            obj.open()
            snap_handle = self.snapshot.open(self.container.coh, self.snapshot.epoch)
            thedata2 = self.container.read_an_obj(datasize, dkey, akey, obj,
                                                  snap_handle.value)
            self.log.info("==(2)snapshot test loop: {0}"\
                .format(snapshot_index))
            self.log.info("==self.container_epoch= {0}".format(epoch))
            self.log.info("==self.snapshot_list[ind]={0}"\
                .format(self.snapshot))
            self.log.info("==self.snapshot.epoch=  {0}"\
                .format(self.snapshot.epoch))
            self.log.info("==written thedata size= {0}"\
                .format(len(thedata)+1))
            self.log.info("==written thedata={0}".format(thedata))
            self.log.info("==thedata2.value= {0}".format(thedata2.value))
            if thedata2.value != thedata:
                raise Exception("##The data in the snapshot is not the \
                    same as the original data")
            self.log.info("==The snapshot data matches the data originally \
                    written.")
        except Exception as error:
            self.fail("##Error when retrieving the snapshot data.\n{0}"
                .format(error))

        #(3)Test snapshot with an invalid container handler
        try:
            self.log.info("==(3)Snapshot with an invalid container handler.")
            coh = self.container
            self.snapshot = DaosSnapshot(self.context)
            self.snapshot.create(coh, epoch)
        except:
            self.log.info("===>Negative test 1, expecting failed on taking \
                snapshot with an invalid container.coh: {0}".format(coh))
        else:
            self.fail("##Negative test 1 passing, expecting failed on \
                taking snapshot with an invalid container.coh: ",coh)

        #(4)Test snapshot with a NULL container handler
        try:
            self.log.info("==(4)Snapshot with a NULL container handler.")
            coh = None
            self.snapshot = DaosSnapshot(self.context)
            self.snapshot.create(coh, epoch)
        except:
            self.log.info("===>Negative test 2, expecting failed on taking \
                snapshot on a NULL container.coh.")
        else:
            self.fail("##Negative test 2 passing, expecting failed on taking \
                snapshot on a NULL container.coh.")
        #(5)Test snapshot with an invalid epoch
        try:
            self.log.info("==(5)Snapshot with a NULL epoch = ")
            invalid_epoch = None
            self.snapshot = DaosSnapshot(self.context)
            self.snapshot.create(self.container.coh, invalid_epoch)
        except:
            self.log.info("===>Negative test 3, expecting failed on taking \
                snapshot with a NULL epoch.")
        else:
            self.fail("##Negative test 3 passing, expecting failed on taking \
                snapshot with a NULL epoch.")
        self.log.info("==>DAOS container snapshot-create Negative tests passed")


    def test_snapshot_info(self):
        """
        Test ID: DAOS-1386 Test container SnapShot information
                 DAOS-1371 Test list snapshots
                 DAOS-1395 Test snapshot destroy
                 DAOS-1402 Test creating multiple snapshots
        Test Description:
                (1)Create an object, write random adata into it, and take
                   a snapshot.
                (2)Make changes to the data object. The write_an_obj function
                   does a commit when the update is complete.
                (3)Verify the data in the snapshot is the original data.
                   Get a handle for the snapshot and read the object at dkey,
                   akey. Compare it to the originally written data.
                (4)List the snapshot and make sure it reflects the original
                   epoch.
                   ==>Repeat step(1) to step(4) for multiple snapshot tests.
                (5)Verify the snapshots data.
                (6)Destroy the snapshot.
                (7)Check if still able to Open the destroied snapshot and
                   Verify the snapshot removed from the snapshot list.
        Use Cases:
        :avocado: tags=snap,snapshotInfo
        """

        self.coh_list= []
        self.container_epoch_list= []
        self.snapshot_list= []
        self.test_data= []
        snapshot_index = 1
        snapshot_loop = 10
        #
        #Test loop for creat, modify and snapshot object in the DAOS container.
        #
        while snapshot_index <= snapshot_loop:
            #(1)Create an object, write some data into it, and take a snapshot
            try:
                obj_cls = self.params.get("obj_class", '/run/object_class/*')
                dkey = "dkey"
                akey = "akey"
                size = random.randint(1, 100) + 1
                rand_str = lambda n: ''.join([random.choice(string.lowercase)\
                        for i in xrange(n)])
                thedata = "--->>>Happy Daos Snapshot Testing " + \
                        str(snapshot_index) + "<<<---" + rand_str(size)
                datasize = len(thedata) + 1
                obj, epoch = self.container.write_an_obj(thedata,
                                                     datasize,
                                                     dkey,
                                                     akey,
                                                     obj_cls=obj_cls)
                obj.close()
                #Take a snapshot of the container
                self.snapshot = DaosSnapshot(self.context)
                self.snapshot.create(self.container.coh, epoch)
                self.log.info("==Wrote an object and created a snapshot")

                #Display snapshot
                substep = "1." + str(snapshot_index)
                self.log.info("==(1)Test step {0}".format(substep))
                self.log.info("==container epoch=     {0}".format(epoch))
                self.log.info("==self.snapshot.epoch= {0}"\
                    .format(self.snapshot.epoch))
                self.display_Snapshot(self.snapshot)

                #Save snapshot test data
                self.append_snapshot_testdata(self.container.coh, epoch,\
                    self.snapshot, thedata)
                snapshot_index += 1

            except DaosApiError as error:
                self.fail("##Test failed during the initial object write.\n{0}"
                      .format(error))

            #(2)Make changes to the data object. The write_an_obj function does
            #   a commit when the update is complete
            try:
                rand_str = lambda n: ''.join([random.choice(string.lowercase)
                                       for i in xrange(n)])
                self.log.info("==(2)Committing 10 additional transactions to \
                    the same KV.")
                more_transactions = 10
                while more_transactions:
                    size = random.randint(1, 250) + 1
                    new_data = rand_str(size)
                    new_obj, _ = self.container.write_an_obj(new_data,
                                                         size,
                                                         dkey,
                                                         akey,
                                                         obj_cls=obj_cls)
                    new_obj.close()
                    more_transactions -= 1
            except Exception as error:
                self.fail("##Test failed during the write of 10 objects.\n{0}"
                      .format(error))

            #(3)Verify the data in the snapshot is the original data.
            #   Get a handle for the snapshot and read the object at dkey, akey.
            #   Compare it to the originally written data.
            try:
                obj.open()
                snap_handle = self.snapshot.open(self.container.coh, self.snapshot.epoch)
                thedata3 = self.container.read_an_obj(datasize, dkey, akey, obj,
                                                  snap_handle.value)
                self.log.info("==(3)snapshot test loop: {0}"\
                    .format(snapshot_index))
                self.log.info("==self.container_epoch= {0}".format(epoch))
                self.log.info("==self.snapshot_list[ind]={0}"\
                    .format(self.snapshot))
                self.log.info("==self.snapshot.epoch=  {0}"\
                    .format(self.snapshot.epoch))
                self.log.info("==written thedata size= {0}"\
                    .format(len(thedata)+1))
                self.log.info("==written thedata={0}".format(thedata))
                self.log.info("==thedata3.value= {0}".format(thedata3.value))
                if thedata3.value != thedata:
                    raise Exception("##The data in the snapshot is not the \
                        same as the original data")
                self.log.info("==The snapshot data matches the data originally \
                        written.")
            except Exception as error:
                self.fail("##Error when retrieving the snapshot data.\n{0}"
                    .format(error))

            #(4)List the snapshot and make sure it reflects the original epoch
            try:
                reported_epoch = self.snapshot.list(self.container.coh, epoch)
                self.log.info("==(4)List snapshot reported_epoch={0}"\
                    .format(reported_epoch))
                self.log.info("     self.snapshot.epoch={0}"\
                    .format(self.snapshot.epoch))
                #self.cancel("tickets already assigned DAOS-2390 DAOS-2392")
                #if self.snapshot.epoch != reported_epoch:
                    #raise Exception("##The snapshot epoch returned from "
                    #        "snapshot list is not the same as the original "
                    #        "epoch list is not the same as the original epoch"
                    #        "snapshotted.")
                self.log.info("==After 10 additional commits the snapshot is "
                   "still available")
            except Exception as error:
                self.fail("##Test was unable to list the snapshot\n{0}"
                   .format(error))

        #(5)Verify the snapshots data
        try:
            for ind in range(0, len(self.container_epoch_list)):
                epoch = self.container_epoch_list[ind]
                ss = self.snapshot_list[ind]
                datasize = len(self.test_data[ind]) + 1
                obj.open()
                snap_handle = self.snapshot.open(self.container.coh, ss.epoch)
                thedata3 = self.container.read_an_obj(datasize, dkey, akey, obj,
                                                  snap_handle.value)
                self.log.info("==(5)snapshot test list {0}:".format(ind+1))
                self.log.info("==self.container_epoch_list[ind]={0}"\
                    .format(epoch))
                self.log.info("==self.snapshot_list[ind]={0}"\
                    .format(self.snapshot_list[ind]))
                self.log.info("==self.snapshot_list[ind].epoch={0}"\
                    .format( ss.epoch))
                self.log.info("==self.test_data_size=    {0}".format(datasize))
                self.log.info("==thedata3.value=         {0}"\
                    .format(thedata3.value))
                self.log.info("==self.test_data[ind]=    {0}"\
                    .format( self.test_data[ind]))
                #self.cancel("tickets already assigned DAOS-2484")
                #if thedata3.value != self.test_data[ind]:
                #    raise Exception("##The data in the snapshot is not "
                #                    "same as the original data")
                #self.log.info("The snapshot data matches the data originally "
                #    "written.")
        except Exception as error:
            self.fail("Error when retrieving the snapshot data.\n{0}"
                .format(error))

        #(6)Destroy the snapshot
        self.log.info("==(6)Destroy snapshot  epoch:{0}".format(epoch))
        try:
            self.snapshot.destroy(self.container.coh, epoch)
            self.log.info("==Snapshot successfully destroyed")
        except Exception as error:
                self.fail("##{0}".format(error))

        #(7)Check if still able to Open the destroied snapshot and
        #    Verify the snapshot removed from the snapshot list
        try:
            obj.open()
            snap_handle3 = self.snapshot.open(self.container.coh,
                self.snapshot.epoch)
            thedata3 = self.container.read_an_obj(datasize, dkey, akey,
                obj, snap_handle3.value)
            self.log.info("-->thedata_after_snapshot.destroied.value= {0}"\
                .format(thedata3.value))
            self.log.info("==>snapshot_epoch=     {0}"\
                .format(self.snapshot.epoch))
            self.log.info("-->snapshot.list(self.container.coh,epoch)={0}"\
                .format(self.snapshot.list(self.container.coh,epoch)))
            #self.cancel("tickets already assigned DAOS-2390 DAOS-2392")
            #Still able to open the snapshot and read data after destroyed.

        except Exception as error:
            self.fail("##(7)Error when retrieving the 2nd snapshot data.\n{0}"\
                .format(error))
        self.log.info("==>DAOS container SnapshotInfo test passed")
