#!/usr/bin/python
'''
  (C) Copyright 2019 Intel Corporation.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  GOVERNMENT LICENSE RIGHTS-OPEN SOURCE SOFTWARE
  The Government's rights to use, modify, reproduce, release, perform, display,
  or disclose this software are subject to the terms of the Apache License as
  provided in Contract No. B609815.
  Any reproduction of computer software, computer software documentation, or
  portions thereof marked with this legend must also reproduce the markings.
'''
import os
import json
import re

from avocado import Test as avocadoTest
from avocado import skip, TestFail
from avocado.utils import process
from ClusterShell.NodeSet import NodeSet, NodeSetParseError

from configuration_utils import Configuration
from fault_config_utils import write_fault_file
from host_utils import HostManager
from logger_utils import TestLogger
from pydaos.raw import DaosContext, DaosLog, DaosApiError


# pylint: disable=invalid-name
def skipForTicket(ticket):
    """Skip a test with a comment about a ticket."""
    return skip("Skipping until {} is fixed.".format(ticket))
# pylint: enable=invalid-name


class Test(avocadoTest):
    """Basic Test class.

    :avocado: recursive
    """

    def __init__(self, *args, **kwargs):
        """Initialize a Test object."""
        super(Test, self).__init__(*args, **kwargs)
        # set a default timeout of 1 minute
        # tests that want longer should set a timeout in their .yaml file
        # all tests should set a timeout and 60 seconds will enforce that
        if not self.timeout:
            self.timeout = 60

        try:
            self.job_id = self.logdir.split("/")[-3]
        except IndexError:
            self.job_id = "UNKNOWN"

        self.log.info("Job-ID: %s", self.job_id)
        self.log.info("Test PID: %s", os.getpid())

    # pylint: disable=invalid-name
    def cancelForTicket(self, ticket):
        """Skip a test due to a ticket needing to be completed."""
        return self.cancel("Skipping until {} is fixed.".format(ticket))
    # pylint: enable=invalid-name


class TestWithoutServers(Test):
    """Run tests without DAOS servers.

    :avocado: recursive
    """

    def __init__(self, *args, **kwargs):
        """Initialize a TestWithoutServers object."""
        super(TestWithoutServers, self).__init__(*args, **kwargs)

        # Initialize class attributes
        self.basepath = None
        self.prefix = None
        self.ompi_prefix = None
        self.cart_prefix = None
        self.bin = None
        self.ompi_bin = None
        self.cart_bin = None
        self.daos_test = None
        self.orterun = None
        self.daosctl = None
        self.tmp = None
        self.fault_file = None
        self.context = None
        self.d_log = None
        self.test_log = None

    def setUp(self):
        """Set up run before each test."""
        super(TestWithoutServers, self).setUp()
        # get paths from the build_vars generated by build
        with open('../../.build_vars.json') as build_vars:
            build_paths = json.load(build_vars)
        self.basepath = os.path.normpath(
            os.path.join(build_paths['PREFIX'], '..') + os.path.sep)
        self.prefix = build_paths['PREFIX']
        self.ompi_prefix = build_paths['OMPI_PREFIX']
        self.cart_prefix = build_paths['CART_PREFIX']
        self.bin = os.path.join(self.prefix, 'bin')
        self.ompi_bin = os.path.join(self.ompi_prefix, 'bin')
        self.cart_bin = os.path.join(self.cart_prefix, 'bin')
        self.daos_test = os.path.join(self.bin, 'daos_test')
        self.orterun = os.path.join(self.ompi_bin, 'orterun')
        self.daosctl = os.path.join(self.bin, 'daosctl')

        # set default shared dir for daos tests in case DAOS_TEST_SHARED_DIR
        # is not set, for RPM env and non-RPM env.
        if self.prefix != "/usr":
            self.tmp = os.path.join(self.prefix, 'tmp')
        else:
            self.tmp = os.getenv(
                'DAOS_TEST_SHARED_DIR', os.path.expanduser('~/daos_test'))
        if not os.path.exists(self.tmp):
            os.makedirs(self.tmp)

        # setup fault injection, this MUST be before API setup
        fault_list = self.params.get("fault_list", '/run/faults/*/')
        if fault_list:
            # not using workdir because the huge path was messing up
            # orterun or something, could re-evaluate this later
            self.fault_file = write_fault_file(self.tmp, fault_list, None)
            os.environ["D_FI_CONFIG"] = self.fault_file

        self.context = DaosContext(os.path.join(self.prefix, 'lib64'))
        self.d_log = DaosLog(self.context)
        self.test_log = TestLogger(self.log, self.d_log)

    def tearDown(self):
        """Tear down after each test case."""
        super(TestWithoutServers, self).tearDown()

        if self.fault_file:
            os.remove(self.fault_file)


class TestWithServers(TestWithoutServers):
    """Run tests with DAOS servers and at least one client.

    Optionally run DAOS clients on specified hosts.  By default run a single
    DAOS client on the host executing the test.

    :avocado: recursive
    """

    def __init__(self, *args, **kwargs):
        """Initialize a TestWithServers object."""
        super(TestWithServers, self).__init__(*args, **kwargs)

        # Definbe the number of slots to assign to each host in their hostfile
        self.hostfile_servers_slots = 1
        self.hostfile_clients_slots = 1

        # HostManager attribute
        #   - defines all the information used to start the daos_server and
        #     daos_agent processes
        self.manager = HostManager()

        # Configuration attributes
        self.config = None
        self.debug = False

        # Attributes that control the starting of servers and agents
        self.setup_start_servers = True
        self.setup_start_agents = True

        # Pool and Container attributes
        #   - If set to a singe object or list of objects of type
        #     Test[Pool|Container] or Daos[Pool|Container] object, respectively,
        #     this class will close and destroy the pool(s) and container(s)
        #     during tear down.
        self.pool = None
        self.container = None

        # Log file attributes
        self.agent_log = None
        self.server_log = None
        self.client_log = None
        self.log_dir = os.path.split(
            os.getenv("D_LOG_FILE", "/tmp/server.log"))[0]
        self.test_id = "{}-{}".format(
            os.path.split(self.filename)[1], self.name.str_uid)

    def setUp(self):
        """Set up each test case."""
        super(TestWithServers, self).setUp()

        # Determine which hosts to use as servers and clients/agents.
        self.manager.get_params(self)

        # Find a configuration that meets the test requirements
        self.config = Configuration(
            self.params, self.manager.test_servers, debug=self.debug)
        if not self.config.set_config(self):
            self.cancel("Test requirements not met!")

        # Prepare the hosts for testing
        self.manager.prepare()

        # Start the clients (agents)
        if self.setup_start_agents:
            self.manager.start_agents(self)

        # Start the servers
        if self.setup_start_servers:
            self.manager.start_servers(self)

    def tearDown(self):
        """Tear down after each test case."""
        # Destroy any containers first
        errors = self.destroy_containers(self.container)

        # Destroy any pools next
        errors.extend(self.destroy_pools(self.pool))

        # Stop the agents
        errors.extend(self.manager.stop_agents())

        # Stop the servers
        errors.extend(self.manager.stop_servers())

        # Complete tear down actions from the inherited class
        try:
            super(TestWithServers, self).tearDown()
        except OSError as error:
            errors.append(
                "Error running inheritted teardown(): {}".format(error))

        # Fail the test if any errors occurred during tear down
        if errors:
            self.fail(
                "Errors detected during teardown:\n  - {}".format(
                    "\n  - ".join(errors)))

    def destroy_containers(self, containers):
        """Close and destroy one or more containers.

        Args:
            containers (object): a list of or single DaosContainer or
                TestContainer object(s) to destroy

        Returns:
            list: a list of exceptions raised destroying the containers

        """
        error_list = []
        if containers:
            if not isinstance(containers, (list, tuple)):
                containers = [containers]
            self.test_log.info("Destroying containers")
            for container in containers:
                # Only close a container that has been openned by the test
                if not hasattr(container, "opened") or container.opened:
                    try:
                        container.close()
                    except (DaosApiError, TestFail) as error:
                        self.test_log.info("  {}".format(error))
                        error_list.append(
                            "Error closing the container: {}".format(error))

                # Only destroy a container that has been created by the test
                if not hasattr(container, "attached") or container.attached:
                    try:
                        container.destroy()
                    except (DaosApiError, TestFail) as error:
                        self.test_log.info("  {}".format(error))
                        error_list.append(
                            "Error destroying container: {}".format(error))
        return error_list

    def destroy_pools(self, pools):
        """Disconnect and destroy one or more pools.

        Args:
            pools (object): a list of or single DaosPool or TestPool object(s)
                to destroy

        Returns:
            list: a list of exceptions raised destroying the pools

        """
        error_list = []
        if pools:
            if not isinstance(pools, (list, tuple)):
                pools = [pools]
            self.test_log.info("Destroying pools")
            for pool in pools:
                # Only disconnect a pool that has been connected by the test
                if not hasattr(pool, "connected") or pool.connected:
                    try:
                        pool.disconnect()
                    except (DaosApiError, TestFail) as error:
                        self.test_log.info("  {}".format(error))
                        error_list.append(
                            "Error disconnecting pool: {}".format(error))

                # Only destroy a pool that has been created by the test
                if not hasattr(pool, "attached") or pool.attached:
                    try:
                        pool.destroy(1)
                    except (DaosApiError, TestFail) as error:
                        self.test_log.info("  {}".format(error))
                        error_list.append(
                            "Error destroying pool: {}".format(error))
        return error_list

    def update_log_file_names(self, test_name=None):
        """Set unique log file names for agents, servers, and clients.

        Args:
            test_name (str, optional): name of test variant. Defaults to None.
        """
        if test_name:
            self.test_id = test_name

        self.agent_log = os.path.join(
            self.log_dir, "{}_agent_daos.log".format(self.test_id))
        self.server_log = os.path.join(
            self.log_dir, "{}_server_daos.log".format(self.test_id))
        self.client_log = os.path.join(
            self.log_dir, "{}_client_daos.log".format(self.test_id))
